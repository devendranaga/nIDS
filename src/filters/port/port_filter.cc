#include <event_mgr.h>
#include <parser.h>
#include <port_filter.h>

namespace firewall {

bool inline in_range(uint32_t val, uint32_t min, uint32_t max)
{
    if ((val >= min) && (val <= max))
        return true;

    return false;
}

void port_filter::match_port_ranges(parser &p,
                                    std::vector<rule_config_item>::iterator &rule,
                                    logger *log,
                                    bool debug)
{
    event_mgr *evt_mgr = event_mgr::instance();
    event_type evt_type = event_type::Evt_Deny;
    uint32_t src_port;
    uint32_t dst_port;

    if (p.protocols_avail.has_tcp()) {
        src_port = p.tcp_h.src_port;
        dst_port = p.tcp_h.dst_port;
    } else if (p.protocols_avail.has_udp()) {
        src_port = p.udp_h.src_port;
        dst_port = p.udp_h.dst_port;
    } else {
        //
        // should we raise an event ?
        return;
    }

    //
    // we can check only either src or dst port falling in the range
    // this is because the target port could be in range but the sender
    // port may be beyond which is generated by the OS.
    // So we need a direction variable here which specify that the
    // direction is from outwards network into the internal or vice versa
    // and we might need list of servers on internal network as well.
    // So to complicate things less, lets allow either source or target port
    if ((in_range(src_port,
                 rule->port_rule.port_range_min,
                 rule->port_rule.port_range_max)) ||
        (in_range(dst_port,
                  rule->port_rule.port_range_min,
                  rule->port_rule.port_range_max))) {
        if (rule->type == rule_type::Deny)
            evt_type = event_type::Evt_Deny;
        else if (rule->type == rule_type::Allow)
            evt_type = event_type::Evt_Allow;

        evt_mgr->store(evt_type, event_description::Evt_Port_Matched, p);
    }
}

void port_filter::run(parser &p,
                      std::vector<rule_config_item>::iterator &rule,
                      logger *log,
                      bool debug)
{
    if (rule->sig_mask.port_list_sig.port_list)
        match_allowed_ports(p, rule, log, debug);
    if (rule->sig_mask.port_list_sig.port_range)
        match_port_ranges(p, rule, log, debug);
}

void port_filter::match_allowed_ports(parser &p,
                                      std::vector<rule_config_item>::iterator &rule,
                                      logger *log,
                                      bool debug)
{
    bool match = false;
    event_type evt_type;
    event_mgr *evt_mgr = event_mgr::instance();

    match = match_ports(rule->port_rule.port_list, p, log, debug);
    if (match == false)
        evt_type = event_type::Evt_Deny;
    else
        evt_type = event_type::Evt_Allow;

    evt_mgr->store(evt_type, event_description::Evt_Port_Matched, p);
}

bool port_filter::match_ports(std::vector<uint16_t> &port_list,
                              parser &p,
                              logger *log,
                              bool debug)
{
    for (auto it : port_list) {
        if (p.protocols_avail.has_tcp()) {
            if ((it == p.tcp_h.src_port) || (it == p.tcp_h.dst_port)) {
                return true;
            }
        }
        if (p.protocols_avail.has_udp()) {
            if ((it == p.udp_h.src_port) || (it == p.udp_h.dst_port)) {
                return true;
            }
        }
    }

    return false;
}

void port_filter::init()
{

}

}

